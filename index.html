<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Sky and Clouds Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; background: transparent !important; }
  </style>
</head>
<body>
  <div id="sky-gradient" style="
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
    transition: background 1s;
  "></div>
  <button id="time-btn" style="
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 10;
    padding: 12px 20px;
    border-radius: 8px;
    border: none;
    background: rgba(255,255,255,0.8);
    color: #222;
    font-size: 1rem;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  ">Change Time</button>

  <script type="module">
    import * as THREE from './three.module.js';
    import { OrbitControls } from './OrbitControls.js';
    import Sky from './components/Sky.js';
    import CloudSystem from './components/CloudSystem.js';
    import WeatherDisplay from './components/WeatherDisplay.js';

    // Scene setup
    const scene = new THREE.Scene();

    // Camera
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 50);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Ensure canvas is above the gradient
    renderer.domElement.style.position = 'relative';
    renderer.domElement.style.zIndex = 1;

    // Initialize components
    const sky = new Sky(scene);
    const cloudSystem = new CloudSystem(scene);
    const weatherDisplay = new WeatherDisplay();

    const controls = new OrbitControls(camera, renderer.domElement);

    // --- Starfield setup ---
    let stars;
    function createStars() {
      const starCount = 400;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      for (let i = 0; i < starCount; i++) {
        // Place stars in a sphere around the camera
        const r = 200 + Math.random() * 200;
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        positions.push(
          r * Math.sin(phi) * Math.cos(theta),
          r * Math.sin(phi) * Math.sin(theta),
          r * Math.cos(phi)
        );
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, sizeAttenuation: true });
      stars = new THREE.Points(geometry, material);
      stars.visible = false;
      scene.add(stars);
    }
    createStars();

    // Time-of-day logic with gradients
    const times = ['day', 'dusk', 'night', 'dawn'];
    let currentTimeIndex = 0;
    const gradients = {
      day: "linear-gradient(to top, #a1cae0, #478bbe, #1d68aa)",
      dusk: "linear-gradient(0deg, #46466c 0%, #bd4f77 50%, #f2b080 100%)",
      night: "linear-gradient(to top, #283e51, #00001c)",
      dawn: "linear-gradient(0deg, #f2b080 0%, #bd4f77 50%, #46466c 100%)"
    };
    const cloudLayerColors = {
      day: {
        back:  { color: 0xffffff, opacity: 0.8 },
        mid:   { color: 0x9ea8b3, opacity: 0.5 },
        front: { color: 0x000000, opacity: 0.3 }
      },
      dusk: {
        back:  { color: 0xe5987e, opacity: 0.5 },
        mid:   { color: 0xc9667a, opacity: 0.5 },
        front: { color: 0x403073, opacity: 0.8 }
      },
      dawn: {
        back:  { color: 0xe5987e, opacity: 0.5 },
        mid:   { color: 0xc9667a, opacity: 0.5 },
        front: { color: 0x403073, opacity: 0.8 }
      },
      night: {
        back:  { color: 0xadf4f8, opacity: 0.9 },
        mid:   { color: 0x16465c, opacity: 0.8 },
        front: { color: 0x000000, opacity: 0.8 }
      }
    };

    function updateSky() {
      const time = times[currentTimeIndex];
      document.getElementById('sky-gradient').style.background = gradients[time];
      if (stars) stars.visible = (time === 'night');
      // Update cloud color/opacity per layer
      cloudSystem.setCloudColorLayered(cloudLayerColors[time]);
      // Set weather display text color for night mode
      weatherDisplay.setNightMode(time === 'night');
      // Optionally, still update the Three.js sky color for lighting consistency:
      // sky.sky.material.color.setHex(skyColors[time]);
    }
    document.getElementById('time-btn').addEventListener('click', () => {
      currentTimeIndex = (currentTimeIndex + 1) % times.length;
      updateSky();
    });
    updateSky();

    // Fetch weather data and apply to scene
    async function fetchWeather() {
      try {
        const res = await fetch('http://localhost:5173/weather');
        const data = await res.json();
        return data;
      } catch (e) {
        console.error('Weather fetch error:', e);
        return null;
      }
    }

    function applyWeather(weather) {
      console.log(weather);
      if (!weather) return;
      // 1. Set time of day
      const now = Math.floor(Date.now() / 1000); // current time in seconds

      const { sunrise, sunset } = weather.sys;
      let timeOfDay = 'day';

      if (now < sunrise + 3600) timeOfDay = 'dawn';
      else if (now > sunset - 3600 && now < sunset) timeOfDay = 'dusk';
      else if (now < sunrise || now > sunset) timeOfDay = 'night';
      else timeOfDay = 'day';

      currentTimeIndex = times.indexOf(timeOfDay);
      updateSky();
      // 2. Set cloud density
      const cloudiness = weather.clouds.all; // 0-100
      cloudSystem.setCloudDensity(cloudiness);
      // 3. (Optional) Map weather type to other effects
      // e.g., if (weather.weather[0].main === 'Rain') { ... }

      // 4. Show weather info
      weatherDisplay.update(weather);
    }

    // Call after scene setup
    fetchWeather().then(applyWeather);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      cloudSystem.update();
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Responsive resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html> 