<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Sky and Clouds Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; background: transparent !important; }
  </style>
</head>
<body>
  <div id="sky-gradient" style="
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
    transition: background 1s;
  "></div>
  <button id="time-btn" style="
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 10;
    padding: 12px 20px;
    border-radius: 8px;
    border: none;
    background: rgba(255,255,255,0.8);
    color: #222;
    font-size: 1rem;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  ">Change Time</button>

  <script type="module">
    import * as THREE from './three.module.js';
    import { OrbitControls } from './OrbitControls.js';
    import Sky from './components/Sky.js';
    import CloudSystem from './components/CloudSystem.js';
    import WeatherDisplay from './components/WeatherDisplay.js';
    import RainSystem from './components/RainSystem.js';

    // Scene setup
    const scene = new THREE.Scene();

    // Camera
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 50);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Ensure canvas is above the gradient
    renderer.domElement.style.position = 'relative';
    renderer.domElement.style.zIndex = 1;

    // Initialize components
    const sky = new Sky(scene);
    const cloudSystem = new CloudSystem(scene);
    const weatherDisplay = new WeatherDisplay();
    const rainSystem = new RainSystem(scene);

    // Add lighting for clouds
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 50);
    scene.add(directionalLight);

    const controls = new OrbitControls(camera, renderer.domElement);

    // --- Starfield setup ---
    let stars;
    function createStars() {
      const starCount = 400;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      for (let i = 0; i < starCount; i++) {
        // Place stars in a sphere around the camera
        const r = 200 + Math.random() * 200;
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        positions.push(
          r * Math.sin(phi) * Math.cos(theta),
          r * Math.sin(phi) * Math.sin(theta),
          r * Math.cos(phi)
        );
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, sizeAttenuation: true });
      stars = new THREE.Points(geometry, material);
      stars.visible = false;
      scene.add(stars);
    }
    createStars();

    // Time-of-day logic with gradients
    const times = ['day', 'dusk', 'night', 'dawn'];
    let currentTimeIndex = 0;
    const gradients = {
      day: "linear-gradient(to top, #a1cae0, #478bbe, #1d68aa)",
      dusk: "linear-gradient(0deg, #46466c 0%, #bd4f77 50%, #f2b080 100%)",
      night: "linear-gradient(to top, #283e51, #00001c)",
      dawn: "linear-gradient(0deg, #f2b080 0%, #bd4f77 50%, #46466c 100%)"
    };
    const greyGradients = {
      day: "linear-gradient(to top, #bfc7ce, #8a99a8, #5c6a7a)",
      dusk: "linear-gradient(0deg, #6c6c7a 0%, #a07a8a 50%, #bfae9e 100%)",
      night: "linear-gradient(to top, #44495a, #23243a)",
      dawn: "linear-gradient(0deg, #bfae9e 0%, #a07a8a 50%, #6c6c7a 100%)"
    };
    let currentCloudiness = 0;

    const cloudLayerColors = {
      day: {
        back:  { color: 0xffffff, opacity: 0.8 },
        mid:   { color: 0x9ea8b3, opacity: 0.5 },
        front: { color: 0x000000, opacity: 0.3 }
      },
      dusk: {
        back:  { color: 0xe5987e, opacity: 0.5 },
        mid:   { color: 0xc9667a, opacity: 0.5 },
        front: { color: 0x403073, opacity: 0.8 }
      },
      dawn: {
        back:  { color: 0xe5987e, opacity: 0.5 },
        mid:   { color: 0xc9667a, opacity: 0.5 },
        front: { color: 0x403073, opacity: 0.8 }
      },
      night: {
        back:  { color: 0xadf4f8, opacity: 0.9 },
        mid:   { color: 0x16465c, opacity: 0.8 },
        front: { color: 0x000000, opacity: 0.8 }
      }
    };

    function updateSky() {
      const time = times[currentTimeIndex];
      // Use grey gradient if very cloudy
      const useGrey = currentCloudiness >= 70;
      const gradient = useGrey ? greyGradients[time] : gradients[time];
      document.getElementById('sky-gradient').style.background = gradient;
      if (stars) stars.visible = (time === 'night');
      cloudSystem.setCloudColorLayered(cloudLayerColors[time]);
      weatherDisplay.setNightMode(time === 'night');
    }
    document.getElementById('time-btn').addEventListener('click', () => {
      currentTimeIndex = (currentTimeIndex + 1) % times.length;
      updateSky();
    });
    updateSky();

    // Fetch weather data and apply to scene
    async function fetchWeather() {
      try {
        const res = await fetch('http://localhost:5173/weather');
        const data = await res.json();
        return data;
      } catch (e) {
        console.error('Weather fetch error:', e);
        return null;
      }
    }

    function applyWeather(weather) {
      console.log('Weather data:', weather);
      if (!weather) return;
      // 1. Set time of day
      const now = Math.floor(Date.now() / 1000); // current time in seconds

      const { sunrise, sunset } = weather.sys;
      let timeOfDay = 'day';

      if (now < sunrise + 3600) timeOfDay = 'dawn';
      else if (now > sunset - 3600 && now < sunset) timeOfDay = 'dusk';
      else if (now < sunrise || now > sunset) timeOfDay = 'night';
      else timeOfDay = 'day';

      currentTimeIndex = times.indexOf(timeOfDay);
      
      // 2. Set cloud density
      const cloudiness = weather.clouds?.all || 0; // Safely access cloud coverage
      currentCloudiness = cloudiness;
      cloudSystem.setCloudDensity(cloudiness);

      // 3. Set rain intensity based on weather condition
      const rainIntensity = weather.rain ? weather.rain['1h'] || weather.rain['3h'] || 0 : 0;
      rainSystem.setRainIntensity(rainIntensity);

      // 4. Show weather info
      weatherDisplay.update(weather);

      // 5. Update sky after all weather parameters are set
      updateSky();
    }

    // Call after scene setup
    fetchWeather().then(applyWeather);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      cloudSystem.update();
      rainSystem.update();
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Responsive resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html> 